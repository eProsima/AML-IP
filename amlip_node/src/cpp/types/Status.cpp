// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file Status.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool fastddsgen and refactored by a proto-intelligent try-hard human.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

#include <network/topics.hpp>
#include <amlip_node/types/Status.hpp>

namespace eprosima {
namespace amlip {
namespace types {

Status::Status(
        AmlipId id,
        NodeKind node_kind,
        StatusKind status)
    : id_(id)
    , node_kind_(node_kind)
    , status_(status)
{
}

Status::Status()
    : Status(AmlipId::undefined_id(), UNDETERMINED, UNKNOWN)
{
}

Status::~Status()
{
}

Status::Status(
        const Status& x)
{
    id_ = x.id_;
    node_kind_ = x.node_kind_;
    status_ = x.status_;
}

Status::Status(
        Status&& x)
{
    id_ = std::move(x.id_);
    node_kind_ = x.node_kind_;
    status_ = x.status_;
}

Status& Status::operator =(
        const Status& x)
{
    id_ = x.id_;
    node_kind_ = x.node_kind_;
    status_ = x.status_;

    return *this;
}

Status& Status::operator =(
        Status&& x)
{
    id_ = std::move(x.id_);
    node_kind_ = x.node_kind_;
    status_ = x.status_;

    return *this;
}

bool Status::operator ==(
        const Status& x) const
{
    return (id_ == x.id_ && node_kind_ == x.node_kind_ && status_ == x.status_);
}

bool Status::operator !=(
        const Status& x) const
{
    return !(*this == x);
}

size_t Status::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    // Id max cdr size
    current_alignment += AmlipId::getMaxCdrSerializedSize(current_alignment);
    // 4 for space between values + 4 for each enumeration value (int)
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // TODO: check that this - operation is not needed
    return current_alignment - initial_alignment;
}

size_t Status::getCdrSerializedSize(
        const Status& data,
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    // Id max cdr size
    current_alignment += AmlipId::getCdrSerializedSize(data.id(), current_alignment);
    // 4 for space between values + 4 for each enumeration value (int)
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    // TODO: check that this - operation is not needed
    return current_alignment - initial_alignment;
}

void Status::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{
    scdr << id_;
    scdr << (uint32_t)node_kind_;
    scdr << (uint32_t)status_;

}

void Status::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> id_;

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        node_kind_ = (NodeKind)enum_value;
    }

    {
        uint32_t enum_value = 0;
        dcdr >> enum_value;
        status_ = (StatusKind)enum_value;
    }

}

/*!
 * @brief This function copies the value in member id
 * @param _id New value to be copied in member id
 */
void Status::id(
        const AmlipId& _id)
{
    id_ = _id;
}

/*!
 * @brief This function moves the value in member id
 * @param _id New value to be moved in member id
 */
void Status::id(
        AmlipId&& _id)
{
    id_ = std::move(_id);
}

/*!
 * @brief This function returns a constant reference to member id
 * @return Constant reference to member id
 */
const AmlipId& Status::id() const
{
    return id_;
}

/*!
 * @brief This function sets a value in member node_kind
 * @param _node_kind New value for member node_kind
 */
void Status::node_kind(
        NodeKind _node_kind)
{
    node_kind_ = _node_kind;
}

/*!
 * @brief This function returns the value of member node_kind
 * @return Value of member node_kind
 */
NodeKind Status::node_kind() const
{
    return node_kind_;
}

/*!
 * @brief This function sets a value in member status
 * @param _status New value for member status
 */
void Status::status(
        StatusKind _status)
{
    status_ = _status;
}

/*!
 * @brief This function returns the value of member status
 * @return Value of member status
 */
StatusKind Status::status() const
{
    return status_;
}

size_t Status::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    return current_alignment;
}

bool Status::isKeyDefined()
{
    return false;
}

void Status::serializeKey(
        eprosima::fastcdr::Cdr&) const
{
}

const char* Status::type_name()
{
    return network::STATUS_TOPIC_DATATYPE;
}

bool Status::is_bounded()
{
    return true;
}

bool Status::is_plain()
{
    return true;
}

bool Status::construct_sample(
        void* memory)
{
    return new (memory) Status();
}

std::ostream& operator <<(
        std::ostream& os,
        const NodeKind& nk)
{
    switch (nk)
    {
        case types::NodeKind::UNDETERMINED:
            os << "UNDETERMINED";
            break;
        case types::NodeKind::DISCOVERY:
            os << "DISCOVERY";
            break;
        case types::NodeKind::AGENT:
            os << "AGENT";
            break;
        case types::NodeKind::MAIN:
            os << "MAIN";
            break;
        case types::NodeKind::COMPUTATIONAL:
            os << "COMPUTATIONAL";
            break;
        case types::NodeKind::EDGE:
            os << "EDGE";
            break;
        case types::NodeKind::STATUS:
            os << "STATUS";
            break;
        case types::NodeKind::GENERIC:
            os << "GENERIC";
            break;
    }
    return os;
}

std::ostream& operator <<(
        std::ostream& os,
        const StatusKind& sk)
{
    switch (sk)
    {
        case types::StatusKind::UNKNOWN:
            os << "UNKNOWN";
            break;
        case types::StatusKind::RUNNING:
            os << "RUNNING";
            break;
        case types::StatusKind::DISABLED:
            os << "DISABLED";
            break;
    }
    return os;
}

std::ostream& operator <<(
        std::ostream& os,
        const Status& st)
{
    os << "STATUS{id:" << st.id() << ", node_kind:" << st.node_kind() << ", status:" << st.status() << "}";
    return os;
}

} /* namespace types */
} /* namespace amlip */
} /* namespace eprosima */
